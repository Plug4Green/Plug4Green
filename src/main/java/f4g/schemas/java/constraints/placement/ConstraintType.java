//
// This file was generated by the JavaTM Architecture for XML Binding(JAXB) Reference Implementation, vhudson-jaxb-ri-2.1-2 
// See <a href="http://java.sun.com/xml/jaxb">http://java.sun.com/xml/jaxb</a> 
// Any modifications to this file will be lost upon recompilation of the source schema. 
// Generated on: 2013.07.30 at 04:51:12 PM CEST 
//


package java.constraints.placement;

import java.util.ArrayList;
import java.util.List;
import javax.xml.bind.annotation.XmlAccessType;
import javax.xml.bind.annotation.XmlAccessorType;
import javax.xml.bind.annotation.XmlElement;
import javax.xml.bind.annotation.XmlType;


/**
 * <p>Java class for ConstraintType complex type.
 * 
 * <p>The following schema fragment specifies the expected content contained within this class.
 * 
 * <pre>
 * &lt;complexType name="ConstraintType">
 *   &lt;complexContent>
 *     &lt;restriction base="{http://www.w3.org/2001/XMLSchema}anyType">
 *       &lt;sequence>
 *         &lt;element name="Ban" type="{java/constraints/placement}Ban" maxOccurs="unbounded" minOccurs="0"/>
 *         &lt;element name="Capacity" type="{java/constraints/placement}Capacity" maxOccurs="unbounded" minOccurs="0"/>
 *         &lt;element name="Fence" type="{java/constraints/placement}Fence" maxOccurs="unbounded" minOccurs="0"/>
 *         &lt;element name="Gather" type="{java/constraints/placement}Gather" maxOccurs="unbounded" minOccurs="0"/>
 *         &lt;element name="Lonely" type="{java/constraints/placement}Lonely" maxOccurs="unbounded" minOccurs="0"/>
 *         &lt;element name="OneOf" type="{java/constraints/placement}OneOf" maxOccurs="unbounded" minOccurs="0"/>
 *         &lt;element name="Root" type="{java/constraints/placement}Root" maxOccurs="unbounded" minOccurs="0"/>
 *         &lt;element name="Split" type="{java/constraints/placement}Split" maxOccurs="unbounded" minOccurs="0"/>
 *         &lt;element name="Spread" type="{java/constraints/placement}Spread" maxOccurs="unbounded" minOccurs="0"/>
 *       &lt;/sequence>
 *     &lt;/restriction>
 *   &lt;/complexContent>
 * &lt;/complexType>
 * </pre>
 * 
 * 
 */
@XmlAccessorType(XmlAccessType.FIELD)
@XmlType(name = "ConstraintType", propOrder = {
    "ban",
    "capacity",
    "fence",
    "gather",
    "lonely",
    "oneOf",
    "root",
    "split",
    "spread"
})
public class ConstraintType {

    @XmlElement(name = "Ban")
    protected List<Ban> ban;
    @XmlElement(name = "Capacity")
    protected List<Capacity> capacity;
    @XmlElement(name = "Fence")
    protected List<Fence> fence;
    @XmlElement(name = "Gather")
    protected List<Gather> gather;
    @XmlElement(name = "Lonely")
    protected List<Lonely> lonely;
    @XmlElement(name = "OneOf")
    protected List<OneOf> oneOf;
    @XmlElement(name = "Root")
    protected List<Root> root;
    @XmlElement(name = "Split")
    protected List<Split> split;
    @XmlElement(name = "Spread")
    protected List<Spread> spread;

    /**
     * Gets the value of the ban property.
     * 
     * <p>
     * This accessor method returns a reference to the live list,
     * not a snapshot. Therefore any modification you make to the
     * returned list will be present inside the JAXB object.
     * This is why there is not a <CODE>set</CODE> method for the ban property.
     * 
     * <p>
     * For example, to add a new item, do as follows:
     * <pre>
     *    getBan().add(newItem);
     * </pre>
     * 
     * 
     * <p>
     * Objects of the following type(s) are allowed in the list
     * {@link Ban }
     * 
     * 
     */
    public List<Ban> getBan() {
        if (ban == null) {
            ban = new ArrayList<Ban>();
        }
        return this.ban;
    }

    /**
     * Gets the value of the capacity property.
     * 
     * <p>
     * This accessor method returns a reference to the live list,
     * not a snapshot. Therefore any modification you make to the
     * returned list will be present inside the JAXB object.
     * This is why there is not a <CODE>set</CODE> method for the capacity property.
     * 
     * <p>
     * For example, to add a new item, do as follows:
     * <pre>
     *    getCapacity().add(newItem);
     * </pre>
     * 
     * 
     * <p>
     * Objects of the following type(s) are allowed in the list
     * {@link Capacity }
     * 
     * 
     */
    public List<Capacity> getCapacity() {
        if (capacity == null) {
            capacity = new ArrayList<Capacity>();
        }
        return this.capacity;
    }

    /**
     * Gets the value of the fence property.
     * 
     * <p>
     * This accessor method returns a reference to the live list,
     * not a snapshot. Therefore any modification you make to the
     * returned list will be present inside the JAXB object.
     * This is why there is not a <CODE>set</CODE> method for the fence property.
     * 
     * <p>
     * For example, to add a new item, do as follows:
     * <pre>
     *    getFence().add(newItem);
     * </pre>
     * 
     * 
     * <p>
     * Objects of the following type(s) are allowed in the list
     * {@link Fence }
     * 
     * 
     */
    public List<Fence> getFence() {
        if (fence == null) {
            fence = new ArrayList<Fence>();
        }
        return this.fence;
    }

    /**
     * Gets the value of the gather property.
     * 
     * <p>
     * This accessor method returns a reference to the live list,
     * not a snapshot. Therefore any modification you make to the
     * returned list will be present inside the JAXB object.
     * This is why there is not a <CODE>set</CODE> method for the gather property.
     * 
     * <p>
     * For example, to add a new item, do as follows:
     * <pre>
     *    getGather().add(newItem);
     * </pre>
     * 
     * 
     * <p>
     * Objects of the following type(s) are allowed in the list
     * {@link Gather }
     * 
     * 
     */
    public List<Gather> getGather() {
        if (gather == null) {
            gather = new ArrayList<Gather>();
        }
        return this.gather;
    }

    /**
     * Gets the value of the lonely property.
     * 
     * <p>
     * This accessor method returns a reference to the live list,
     * not a snapshot. Therefore any modification you make to the
     * returned list will be present inside the JAXB object.
     * This is why there is not a <CODE>set</CODE> method for the lonely property.
     * 
     * <p>
     * For example, to add a new item, do as follows:
     * <pre>
     *    getLonely().add(newItem);
     * </pre>
     * 
     * 
     * <p>
     * Objects of the following type(s) are allowed in the list
     * {@link Lonely }
     * 
     * 
     */
    public List<Lonely> getLonely() {
        if (lonely == null) {
            lonely = new ArrayList<Lonely>();
        }
        return this.lonely;
    }

    /**
     * Gets the value of the oneOf property.
     * 
     * <p>
     * This accessor method returns a reference to the live list,
     * not a snapshot. Therefore any modification you make to the
     * returned list will be present inside the JAXB object.
     * This is why there is not a <CODE>set</CODE> method for the oneOf property.
     * 
     * <p>
     * For example, to add a new item, do as follows:
     * <pre>
     *    getOneOf().add(newItem);
     * </pre>
     * 
     * 
     * <p>
     * Objects of the following type(s) are allowed in the list
     * {@link OneOf }
     * 
     * 
     */
    public List<OneOf> getOneOf() {
        if (oneOf == null) {
            oneOf = new ArrayList<OneOf>();
        }
        return this.oneOf;
    }

    /**
     * Gets the value of the root property.
     * 
     * <p>
     * This accessor method returns a reference to the live list,
     * not a snapshot. Therefore any modification you make to the
     * returned list will be present inside the JAXB object.
     * This is why there is not a <CODE>set</CODE> method for the root property.
     * 
     * <p>
     * For example, to add a new item, do as follows:
     * <pre>
     *    getRoot().add(newItem);
     * </pre>
     * 
     * 
     * <p>
     * Objects of the following type(s) are allowed in the list
     * {@link Root }
     * 
     * 
     */
    public List<Root> getRoot() {
        if (root == null) {
            root = new ArrayList<Root>();
        }
        return this.root;
    }

    /**
     * Gets the value of the split property.
     * 
     * <p>
     * This accessor method returns a reference to the live list,
     * not a snapshot. Therefore any modification you make to the
     * returned list will be present inside the JAXB object.
     * This is why there is not a <CODE>set</CODE> method for the split property.
     * 
     * <p>
     * For example, to add a new item, do as follows:
     * <pre>
     *    getSplit().add(newItem);
     * </pre>
     * 
     * 
     * <p>
     * Objects of the following type(s) are allowed in the list
     * {@link Split }
     * 
     * 
     */
    public List<Split> getSplit() {
        if (split == null) {
            split = new ArrayList<Split>();
        }
        return this.split;
    }

    /**
     * Gets the value of the spread property.
     * 
     * <p>
     * This accessor method returns a reference to the live list,
     * not a snapshot. Therefore any modification you make to the
     * returned list will be present inside the JAXB object.
     * This is why there is not a <CODE>set</CODE> method for the spread property.
     * 
     * <p>
     * For example, to add a new item, do as follows:
     * <pre>
     *    getSpread().add(newItem);
     * </pre>
     * 
     * 
     * <p>
     * Objects of the following type(s) are allowed in the list
     * {@link Spread }
     * 
     * 
     */
    public List<Spread> getSpread() {
        if (spread == null) {
            spread = new ArrayList<Spread>();
        }
        return this.spread;
    }

}
