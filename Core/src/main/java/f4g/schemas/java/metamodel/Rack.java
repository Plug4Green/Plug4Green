//
// This file was generated by the JavaTM Architecture for XML Binding(JAXB) Reference Implementation, v2.2.11 
// See <a href="http://java.sun.com/xml/jaxb">http://java.sun.com/xml/jaxb</a> 
// Any modifications to this file will be lost upon recompilation of the source schema. 
// Generated on: 2015.08.10 at 04:34:50 PM CEST 
//


package f4g.schemas.java.metamodel;

import java.util.ArrayList;
import java.util.List;
import javax.xml.bind.JAXBElement;
import javax.xml.bind.Unmarshaller;
import javax.xml.bind.annotation.XmlAccessType;
import javax.xml.bind.annotation.XmlAccessorType;
import javax.xml.bind.annotation.XmlElement;
import javax.xml.bind.annotation.XmlSchemaType;
import javax.xml.bind.annotation.XmlTransient;
import javax.xml.bind.annotation.XmlType;
import javax.xml.namespace.QName;
import com.massfords.humantask.Named;
import com.massfords.humantask.Visitable;
import com.massfords.humantask.Visitor;
import org.jvnet.jaxb2_commons.lang.CopyStrategy;
import org.jvnet.jaxb2_commons.lang.CopyTo;
import org.jvnet.jaxb2_commons.lang.JAXBCopyStrategy;
import org.jvnet.jaxb2_commons.locator.ObjectLocator;
import org.jvnet.jaxb2_commons.locator.util.LocatorUtils;


/**
 * <p>Java class for Rack complex type.
 * 
 * <p>The following schema fragment specifies the expected content contained within this class.
 * 
 * <pre>
 * &lt;complexType name="Rack"&gt;
 *   &lt;complexContent&gt;
 *     &lt;restriction base="{http://www.w3.org/2001/XMLSchema}anyType"&gt;
 *       &lt;sequence&gt;
 *         &lt;element name="computedPower" type="{f4g/schemas/java/MetaModel}Power" minOccurs="0"/&gt;
 *         &lt;element ref="{f4g/schemas/java/MetaModel}RackableServer" maxOccurs="unbounded" minOccurs="0"/&gt;
 *         &lt;element ref="{f4g/schemas/java/MetaModel}Fan" maxOccurs="unbounded" minOccurs="0"/&gt;
 *         &lt;element ref="{f4g/schemas/java/MetaModel}WaterCooler" maxOccurs="unbounded" minOccurs="0"/&gt;
 *         &lt;element ref="{f4g/schemas/java/MetaModel}RackableRouter" maxOccurs="unbounded" minOccurs="0"/&gt;
 *         &lt;element ref="{f4g/schemas/java/MetaModel}RackableSwitch" maxOccurs="unbounded" minOccurs="0"/&gt;
 *         &lt;element ref="{f4g/schemas/java/MetaModel}SAN" maxOccurs="unbounded" minOccurs="0"/&gt;
 *         &lt;element ref="{f4g/schemas/java/MetaModel}NAS" maxOccurs="unbounded" minOccurs="0"/&gt;
 *         &lt;element ref="{f4g/schemas/java/MetaModel}Enclosure" maxOccurs="unbounded" minOccurs="0"/&gt;
 *         &lt;element ref="{f4g/schemas/java/MetaModel}PDU" maxOccurs="unbounded" minOccurs="0"/&gt;
 *       &lt;/sequence&gt;
 *     &lt;/restriction&gt;
 *   &lt;/complexContent&gt;
 * &lt;/complexType&gt;
 * </pre>
 * 
 * 
 */
@XmlAccessorType(XmlAccessType.FIELD)
@XmlType(name = "Rack", propOrder = {
    "computedPower",
    "rackableServer",
    "fan",
    "waterCooler",
    "rackableRouter",
    "rackableSwitch",
    "san",
    "nas",
    "enclosure",
    "pdu"
})
public class Rack implements Cloneable, Named, Visitable, CopyTo
{

    @XmlSchemaType(name = "double")
    protected Power computedPower;
    @XmlElement(name = "RackableServer", namespace = "f4g/schemas/java/MetaModel")
    protected List<RackableServer> rackableServer;
    @XmlElement(name = "Fan", namespace = "f4g/schemas/java/MetaModel")
    protected List<Fan> fan;
    @XmlElement(name = "WaterCooler", namespace = "f4g/schemas/java/MetaModel")
    protected List<WaterCooler> waterCooler;
    @XmlElement(name = "RackableRouter", namespace = "f4g/schemas/java/MetaModel")
    protected List<RackableRouter> rackableRouter;
    @XmlElement(name = "RackableSwitch", namespace = "f4g/schemas/java/MetaModel")
    protected List<RackableSwitch> rackableSwitch;
    @XmlElement(name = "SAN", namespace = "f4g/schemas/java/MetaModel")
    protected List<SAN> san;
    @XmlElement(name = "NAS", namespace = "f4g/schemas/java/MetaModel")
    protected List<NAS> nas;
    @XmlElement(name = "Enclosure", namespace = "f4g/schemas/java/MetaModel")
    protected List<Enclosure> enclosure;
    @XmlElement(name = "PDU", namespace = "f4g/schemas/java/MetaModel")
    protected List<PDU> pdu;
    @XmlTransient
    private QName jaxbElementName;

    /**
     * Default no-arg constructor
     * 
     */
    public Rack() {
        super();
    }

    /**
     * Fully-initialising value constructor
     * 
     */
    public Rack(final Power computedPower, final List<RackableServer> rackableServer, final List<Fan> fan, final List<WaterCooler> waterCooler, final List<RackableRouter> rackableRouter, final List<RackableSwitch> rackableSwitch, final List<SAN> san, final List<NAS> nas, final List<Enclosure> enclosure, final List<PDU> pdu, final QName jaxbElementName) {
        this.computedPower = computedPower;
        this.rackableServer = rackableServer;
        this.fan = fan;
        this.waterCooler = waterCooler;
        this.rackableRouter = rackableRouter;
        this.rackableSwitch = rackableSwitch;
        this.san = san;
        this.nas = nas;
        this.enclosure = enclosure;
        this.pdu = pdu;
        this.jaxbElementName = jaxbElementName;
    }

    /**
     * Gets the value of the computedPower property.
     * 
     * @return
     *     possible object is
     *     {@link Power }
     *     
     */
    public Power getComputedPower() {
        return computedPower;
    }

    /**
     * Sets the value of the computedPower property.
     * 
     * @param value
     *     allowed object is
     *     {@link Power }
     *     
     */
    public void setComputedPower(Power value) {
        this.computedPower = value;
    }

    /**
     * Gets the value of the rackableServer property.
     * 
     * <p>
     * This accessor method returns a reference to the live list,
     * not a snapshot. Therefore any modification you make to the
     * returned list will be present inside the JAXB object.
     * This is why there is not a <CODE>set</CODE> method for the rackableServer property.
     * 
     * <p>
     * For example, to add a new item, do as follows:
     * <pre>
     *    getRackableServer().add(newItem);
     * </pre>
     * 
     * 
     * <p>
     * Objects of the following type(s) are allowed in the list
     * {@link RackableServer }
     * 
     * 
     */
    public List<RackableServer> getRackableServer() {
        if (rackableServer == null) {
            rackableServer = new ArrayList<RackableServer>();
        }
        return this.rackableServer;
    }

    /**
     * Gets the value of the fan property.
     * 
     * <p>
     * This accessor method returns a reference to the live list,
     * not a snapshot. Therefore any modification you make to the
     * returned list will be present inside the JAXB object.
     * This is why there is not a <CODE>set</CODE> method for the fan property.
     * 
     * <p>
     * For example, to add a new item, do as follows:
     * <pre>
     *    getFan().add(newItem);
     * </pre>
     * 
     * 
     * <p>
     * Objects of the following type(s) are allowed in the list
     * {@link Fan }
     * 
     * 
     */
    public List<Fan> getFan() {
        if (fan == null) {
            fan = new ArrayList<Fan>();
        }
        return this.fan;
    }

    /**
     * Gets the value of the waterCooler property.
     * 
     * <p>
     * This accessor method returns a reference to the live list,
     * not a snapshot. Therefore any modification you make to the
     * returned list will be present inside the JAXB object.
     * This is why there is not a <CODE>set</CODE> method for the waterCooler property.
     * 
     * <p>
     * For example, to add a new item, do as follows:
     * <pre>
     *    getWaterCooler().add(newItem);
     * </pre>
     * 
     * 
     * <p>
     * Objects of the following type(s) are allowed in the list
     * {@link WaterCooler }
     * 
     * 
     */
    public List<WaterCooler> getWaterCooler() {
        if (waterCooler == null) {
            waterCooler = new ArrayList<WaterCooler>();
        }
        return this.waterCooler;
    }

    /**
     * Gets the value of the rackableRouter property.
     * 
     * <p>
     * This accessor method returns a reference to the live list,
     * not a snapshot. Therefore any modification you make to the
     * returned list will be present inside the JAXB object.
     * This is why there is not a <CODE>set</CODE> method for the rackableRouter property.
     * 
     * <p>
     * For example, to add a new item, do as follows:
     * <pre>
     *    getRackableRouter().add(newItem);
     * </pre>
     * 
     * 
     * <p>
     * Objects of the following type(s) are allowed in the list
     * {@link RackableRouter }
     * 
     * 
     */
    public List<RackableRouter> getRackableRouter() {
        if (rackableRouter == null) {
            rackableRouter = new ArrayList<RackableRouter>();
        }
        return this.rackableRouter;
    }

    /**
     * Gets the value of the rackableSwitch property.
     * 
     * <p>
     * This accessor method returns a reference to the live list,
     * not a snapshot. Therefore any modification you make to the
     * returned list will be present inside the JAXB object.
     * This is why there is not a <CODE>set</CODE> method for the rackableSwitch property.
     * 
     * <p>
     * For example, to add a new item, do as follows:
     * <pre>
     *    getRackableSwitch().add(newItem);
     * </pre>
     * 
     * 
     * <p>
     * Objects of the following type(s) are allowed in the list
     * {@link RackableSwitch }
     * 
     * 
     */
    public List<RackableSwitch> getRackableSwitch() {
        if (rackableSwitch == null) {
            rackableSwitch = new ArrayList<RackableSwitch>();
        }
        return this.rackableSwitch;
    }

    /**
     * Gets the value of the san property.
     * 
     * <p>
     * This accessor method returns a reference to the live list,
     * not a snapshot. Therefore any modification you make to the
     * returned list will be present inside the JAXB object.
     * This is why there is not a <CODE>set</CODE> method for the san property.
     * 
     * <p>
     * For example, to add a new item, do as follows:
     * <pre>
     *    getSAN().add(newItem);
     * </pre>
     * 
     * 
     * <p>
     * Objects of the following type(s) are allowed in the list
     * {@link SAN }
     * 
     * 
     */
    public List<SAN> getSAN() {
        if (san == null) {
            san = new ArrayList<SAN>();
        }
        return this.san;
    }

    /**
     * Gets the value of the nas property.
     * 
     * <p>
     * This accessor method returns a reference to the live list,
     * not a snapshot. Therefore any modification you make to the
     * returned list will be present inside the JAXB object.
     * This is why there is not a <CODE>set</CODE> method for the nas property.
     * 
     * <p>
     * For example, to add a new item, do as follows:
     * <pre>
     *    getNAS().add(newItem);
     * </pre>
     * 
     * 
     * <p>
     * Objects of the following type(s) are allowed in the list
     * {@link NAS }
     * 
     * 
     */
    public List<NAS> getNAS() {
        if (nas == null) {
            nas = new ArrayList<NAS>();
        }
        return this.nas;
    }

    /**
     * Gets the value of the enclosure property.
     * 
     * <p>
     * This accessor method returns a reference to the live list,
     * not a snapshot. Therefore any modification you make to the
     * returned list will be present inside the JAXB object.
     * This is why there is not a <CODE>set</CODE> method for the enclosure property.
     * 
     * <p>
     * For example, to add a new item, do as follows:
     * <pre>
     *    getEnclosure().add(newItem);
     * </pre>
     * 
     * 
     * <p>
     * Objects of the following type(s) are allowed in the list
     * {@link Enclosure }
     * 
     * 
     */
    public List<Enclosure> getEnclosure() {
        if (enclosure == null) {
            enclosure = new ArrayList<Enclosure>();
        }
        return this.enclosure;
    }

    /**
     * Gets the value of the pdu property.
     * 
     * <p>
     * This accessor method returns a reference to the live list,
     * not a snapshot. Therefore any modification you make to the
     * returned list will be present inside the JAXB object.
     * This is why there is not a <CODE>set</CODE> method for the pdu property.
     * 
     * <p>
     * For example, to add a new item, do as follows:
     * <pre>
     *    getPDU().add(newItem);
     * </pre>
     * 
     * 
     * <p>
     * Objects of the following type(s) are allowed in the list
     * {@link PDU }
     * 
     * 
     */
    public List<PDU> getPDU() {
        if (pdu == null) {
            pdu = new ArrayList<PDU>();
        }
        return this.pdu;
    }

    public void setJAXBElementName(QName name) {
        this.jaxbElementName = name;
    }

    public QName getJAXBElementName() {
        return this.jaxbElementName;
    }

    public void afterUnmarshal(Unmarshaller u, Object parent) {
        if (parent instanceof JAXBElement) {
            this.jaxbElementName = ((JAXBElement) parent).getName();
        }
    }

    public void accept(Visitor aVisitor) {
        aVisitor.visit(this);
    }

    public Object clone() {
        return copyTo(createNewInstance());
    }

    public Object copyTo(Object target) {
        final CopyStrategy strategy = JAXBCopyStrategy.INSTANCE;
        return copyTo(null, target, strategy);
    }

    public Object copyTo(ObjectLocator locator, Object target, CopyStrategy strategy) {
        final Object draftCopy = ((target == null)?createNewInstance():target);
        if (draftCopy instanceof Rack) {
            final Rack copy = ((Rack) draftCopy);
            if (this.computedPower!= null) {
                Power sourceComputedPower;
                sourceComputedPower = this.getComputedPower();
                Power copyComputedPower = ((Power) strategy.copy(LocatorUtils.property(locator, "computedPower", sourceComputedPower), sourceComputedPower));
                copy.setComputedPower(copyComputedPower);
            } else {
                copy.computedPower = null;
            }
            if ((this.rackableServer!= null)&&(!this.rackableServer.isEmpty())) {
                List<RackableServer> sourceRackableServer;
                sourceRackableServer = (((this.rackableServer!= null)&&(!this.rackableServer.isEmpty()))?this.getRackableServer():null);
                @SuppressWarnings("unchecked")
                List<RackableServer> copyRackableServer = ((List<RackableServer> ) strategy.copy(LocatorUtils.property(locator, "rackableServer", sourceRackableServer), sourceRackableServer));
                copy.rackableServer = null;
                if (copyRackableServer!= null) {
                    List<RackableServer> uniqueRackableServerl = copy.getRackableServer();
                    uniqueRackableServerl.addAll(copyRackableServer);
                }
            } else {
                copy.rackableServer = null;
            }
            if ((this.fan!= null)&&(!this.fan.isEmpty())) {
                List<Fan> sourceFan;
                sourceFan = (((this.fan!= null)&&(!this.fan.isEmpty()))?this.getFan():null);
                @SuppressWarnings("unchecked")
                List<Fan> copyFan = ((List<Fan> ) strategy.copy(LocatorUtils.property(locator, "fan", sourceFan), sourceFan));
                copy.fan = null;
                if (copyFan!= null) {
                    List<Fan> uniqueFanl = copy.getFan();
                    uniqueFanl.addAll(copyFan);
                }
            } else {
                copy.fan = null;
            }
            if ((this.waterCooler!= null)&&(!this.waterCooler.isEmpty())) {
                List<WaterCooler> sourceWaterCooler;
                sourceWaterCooler = (((this.waterCooler!= null)&&(!this.waterCooler.isEmpty()))?this.getWaterCooler():null);
                @SuppressWarnings("unchecked")
                List<WaterCooler> copyWaterCooler = ((List<WaterCooler> ) strategy.copy(LocatorUtils.property(locator, "waterCooler", sourceWaterCooler), sourceWaterCooler));
                copy.waterCooler = null;
                if (copyWaterCooler!= null) {
                    List<WaterCooler> uniqueWaterCoolerl = copy.getWaterCooler();
                    uniqueWaterCoolerl.addAll(copyWaterCooler);
                }
            } else {
                copy.waterCooler = null;
            }
            if ((this.rackableRouter!= null)&&(!this.rackableRouter.isEmpty())) {
                List<RackableRouter> sourceRackableRouter;
                sourceRackableRouter = (((this.rackableRouter!= null)&&(!this.rackableRouter.isEmpty()))?this.getRackableRouter():null);
                @SuppressWarnings("unchecked")
                List<RackableRouter> copyRackableRouter = ((List<RackableRouter> ) strategy.copy(LocatorUtils.property(locator, "rackableRouter", sourceRackableRouter), sourceRackableRouter));
                copy.rackableRouter = null;
                if (copyRackableRouter!= null) {
                    List<RackableRouter> uniqueRackableRouterl = copy.getRackableRouter();
                    uniqueRackableRouterl.addAll(copyRackableRouter);
                }
            } else {
                copy.rackableRouter = null;
            }
            if ((this.rackableSwitch!= null)&&(!this.rackableSwitch.isEmpty())) {
                List<RackableSwitch> sourceRackableSwitch;
                sourceRackableSwitch = (((this.rackableSwitch!= null)&&(!this.rackableSwitch.isEmpty()))?this.getRackableSwitch():null);
                @SuppressWarnings("unchecked")
                List<RackableSwitch> copyRackableSwitch = ((List<RackableSwitch> ) strategy.copy(LocatorUtils.property(locator, "rackableSwitch", sourceRackableSwitch), sourceRackableSwitch));
                copy.rackableSwitch = null;
                if (copyRackableSwitch!= null) {
                    List<RackableSwitch> uniqueRackableSwitchl = copy.getRackableSwitch();
                    uniqueRackableSwitchl.addAll(copyRackableSwitch);
                }
            } else {
                copy.rackableSwitch = null;
            }
            if ((this.san!= null)&&(!this.san.isEmpty())) {
                List<SAN> sourceSAN;
                sourceSAN = (((this.san!= null)&&(!this.san.isEmpty()))?this.getSAN():null);
                @SuppressWarnings("unchecked")
                List<SAN> copySAN = ((List<SAN> ) strategy.copy(LocatorUtils.property(locator, "san", sourceSAN), sourceSAN));
                copy.san = null;
                if (copySAN!= null) {
                    List<SAN> uniqueSANl = copy.getSAN();
                    uniqueSANl.addAll(copySAN);
                }
            } else {
                copy.san = null;
            }
            if ((this.nas!= null)&&(!this.nas.isEmpty())) {
                List<NAS> sourceNAS;
                sourceNAS = (((this.nas!= null)&&(!this.nas.isEmpty()))?this.getNAS():null);
                @SuppressWarnings("unchecked")
                List<NAS> copyNAS = ((List<NAS> ) strategy.copy(LocatorUtils.property(locator, "nas", sourceNAS), sourceNAS));
                copy.nas = null;
                if (copyNAS!= null) {
                    List<NAS> uniqueNASl = copy.getNAS();
                    uniqueNASl.addAll(copyNAS);
                }
            } else {
                copy.nas = null;
            }
            if ((this.enclosure!= null)&&(!this.enclosure.isEmpty())) {
                List<Enclosure> sourceEnclosure;
                sourceEnclosure = (((this.enclosure!= null)&&(!this.enclosure.isEmpty()))?this.getEnclosure():null);
                @SuppressWarnings("unchecked")
                List<Enclosure> copyEnclosure = ((List<Enclosure> ) strategy.copy(LocatorUtils.property(locator, "enclosure", sourceEnclosure), sourceEnclosure));
                copy.enclosure = null;
                if (copyEnclosure!= null) {
                    List<Enclosure> uniqueEnclosurel = copy.getEnclosure();
                    uniqueEnclosurel.addAll(copyEnclosure);
                }
            } else {
                copy.enclosure = null;
            }
            if ((this.pdu!= null)&&(!this.pdu.isEmpty())) {
                List<PDU> sourcePDU;
                sourcePDU = (((this.pdu!= null)&&(!this.pdu.isEmpty()))?this.getPDU():null);
                @SuppressWarnings("unchecked")
                List<PDU> copyPDU = ((List<PDU> ) strategy.copy(LocatorUtils.property(locator, "pdu", sourcePDU), sourcePDU));
                copy.pdu = null;
                if (copyPDU!= null) {
                    List<PDU> uniquePDUl = copy.getPDU();
                    uniquePDUl.addAll(copyPDU);
                }
            } else {
                copy.pdu = null;
            }
        }
        return draftCopy;
    }

    public Object createNewInstance() {
        return new Rack();
    }

}
