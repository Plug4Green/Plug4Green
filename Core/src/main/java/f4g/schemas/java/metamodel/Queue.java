//
// This file was generated by the JavaTM Architecture for XML Binding(JAXB) Reference Implementation, v2.2.11 
// See <a href="http://java.sun.com/xml/jaxb">http://java.sun.com/xml/jaxb</a> 
// Any modifications to this file will be lost upon recompilation of the source schema. 
// Generated on: 2015.08.10 at 04:34:50 PM CEST 
//


package f4g.schemas.java.metamodel;

import java.util.ArrayList;
import java.util.List;
import javax.xml.bind.JAXBElement;
import javax.xml.bind.Unmarshaller;
import javax.xml.bind.annotation.XmlAccessType;
import javax.xml.bind.annotation.XmlAccessorType;
import javax.xml.bind.annotation.XmlElement;
import javax.xml.bind.annotation.XmlSchemaType;
import javax.xml.bind.annotation.XmlTransient;
import javax.xml.bind.annotation.XmlType;
import javax.xml.namespace.QName;
import com.massfords.humantask.Named;
import com.massfords.humantask.Visitable;
import com.massfords.humantask.Visitor;
import org.jvnet.jaxb2_commons.lang.CopyStrategy;
import org.jvnet.jaxb2_commons.lang.CopyTo;
import org.jvnet.jaxb2_commons.lang.JAXBCopyStrategy;
import org.jvnet.jaxb2_commons.locator.ObjectLocator;
import org.jvnet.jaxb2_commons.locator.util.LocatorUtils;


/**
 * <p>Java class for Queue complex type.
 * 
 * <p>The following schema fragment specifies the expected content contained within this class.
 * 
 * <pre>
 * &lt;complexType name="Queue"&gt;
 *   &lt;complexContent&gt;
 *     &lt;restriction base="{http://www.w3.org/2001/XMLSchema}anyType"&gt;
 *       &lt;sequence&gt;
 *         &lt;element name="priority" type="{f4g/schemas/java/MetaModel}QueuePriority"/&gt;
 *         &lt;element name="possibleProperties" type="{f4g/schemas/java/MetaModel}QueuePossibleProp" maxOccurs="unbounded"/&gt;
 *         &lt;element name="forcedProperties" type="{f4g/schemas/java/MetaModel}QueueForcedProp" maxOccurs="unbounded"/&gt;
 *         &lt;element name="wallTimeLimit" type="{f4g/schemas/java/MetaModel}JobLimit"/&gt;
 *         &lt;element name="numberOfNodesLimit" type="{f4g/schemas/java/MetaModel}JobLimit"/&gt;
 *         &lt;element name="jobs" type="{f4g/schemas/java/MetaModel}Job" maxOccurs="unbounded" minOccurs="0"/&gt;
 *       &lt;/sequence&gt;
 *     &lt;/restriction&gt;
 *   &lt;/complexContent&gt;
 * &lt;/complexType&gt;
 * </pre>
 * 
 * 
 */
@XmlAccessorType(XmlAccessType.FIELD)
@XmlType(name = "Queue", propOrder = {
    "priority",
    "possibleProperties",
    "forcedProperties",
    "wallTimeLimit",
    "numberOfNodesLimit",
    "jobs"
})
public class Queue implements Cloneable, Named, Visitable, CopyTo
{

    @XmlElement(required = true)
    @XmlSchemaType(name = "int")
    protected QueuePriority priority;
    @XmlElement(required = true)
    @XmlSchemaType(name = "string")
    protected List<QueuePossibleProp> possibleProperties;
    @XmlElement(required = true)
    @XmlSchemaType(name = "string")
    protected List<QueueForcedProp> forcedProperties;
    @XmlElement(required = true)
    @XmlSchemaType(name = "int")
    protected JobLimit wallTimeLimit;
    @XmlElement(required = true)
    @XmlSchemaType(name = "int")
    protected JobLimit numberOfNodesLimit;
    protected List<Job> jobs;
    @XmlTransient
    private QName jaxbElementName;

    /**
     * Default no-arg constructor
     * 
     */
    public Queue() {
        super();
    }

    /**
     * Fully-initialising value constructor
     * 
     */
    public Queue(final QueuePriority priority, final List<QueuePossibleProp> possibleProperties, final List<QueueForcedProp> forcedProperties, final JobLimit wallTimeLimit, final JobLimit numberOfNodesLimit, final List<Job> jobs, final QName jaxbElementName) {
        this.priority = priority;
        this.possibleProperties = possibleProperties;
        this.forcedProperties = forcedProperties;
        this.wallTimeLimit = wallTimeLimit;
        this.numberOfNodesLimit = numberOfNodesLimit;
        this.jobs = jobs;
        this.jaxbElementName = jaxbElementName;
    }

    /**
     * Gets the value of the priority property.
     * 
     * @return
     *     possible object is
     *     {@link QueuePriority }
     *     
     */
    public QueuePriority getPriority() {
        return priority;
    }

    /**
     * Sets the value of the priority property.
     * 
     * @param value
     *     allowed object is
     *     {@link QueuePriority }
     *     
     */
    public void setPriority(QueuePriority value) {
        this.priority = value;
    }

    /**
     * Gets the value of the possibleProperties property.
     * 
     * <p>
     * This accessor method returns a reference to the live list,
     * not a snapshot. Therefore any modification you make to the
     * returned list will be present inside the JAXB object.
     * This is why there is not a <CODE>set</CODE> method for the possibleProperties property.
     * 
     * <p>
     * For example, to add a new item, do as follows:
     * <pre>
     *    getPossibleProperties().add(newItem);
     * </pre>
     * 
     * 
     * <p>
     * Objects of the following type(s) are allowed in the list
     * {@link QueuePossibleProp }
     * 
     * 
     */
    public List<QueuePossibleProp> getPossibleProperties() {
        if (possibleProperties == null) {
            possibleProperties = new ArrayList<QueuePossibleProp>();
        }
        return this.possibleProperties;
    }

    /**
     * Gets the value of the forcedProperties property.
     * 
     * <p>
     * This accessor method returns a reference to the live list,
     * not a snapshot. Therefore any modification you make to the
     * returned list will be present inside the JAXB object.
     * This is why there is not a <CODE>set</CODE> method for the forcedProperties property.
     * 
     * <p>
     * For example, to add a new item, do as follows:
     * <pre>
     *    getForcedProperties().add(newItem);
     * </pre>
     * 
     * 
     * <p>
     * Objects of the following type(s) are allowed in the list
     * {@link QueueForcedProp }
     * 
     * 
     */
    public List<QueueForcedProp> getForcedProperties() {
        if (forcedProperties == null) {
            forcedProperties = new ArrayList<QueueForcedProp>();
        }
        return this.forcedProperties;
    }

    /**
     * Gets the value of the wallTimeLimit property.
     * 
     * @return
     *     possible object is
     *     {@link JobLimit }
     *     
     */
    public JobLimit getWallTimeLimit() {
        return wallTimeLimit;
    }

    /**
     * Sets the value of the wallTimeLimit property.
     * 
     * @param value
     *     allowed object is
     *     {@link JobLimit }
     *     
     */
    public void setWallTimeLimit(JobLimit value) {
        this.wallTimeLimit = value;
    }

    /**
     * Gets the value of the numberOfNodesLimit property.
     * 
     * @return
     *     possible object is
     *     {@link JobLimit }
     *     
     */
    public JobLimit getNumberOfNodesLimit() {
        return numberOfNodesLimit;
    }

    /**
     * Sets the value of the numberOfNodesLimit property.
     * 
     * @param value
     *     allowed object is
     *     {@link JobLimit }
     *     
     */
    public void setNumberOfNodesLimit(JobLimit value) {
        this.numberOfNodesLimit = value;
    }

    /**
     * Gets the value of the jobs property.
     * 
     * <p>
     * This accessor method returns a reference to the live list,
     * not a snapshot. Therefore any modification you make to the
     * returned list will be present inside the JAXB object.
     * This is why there is not a <CODE>set</CODE> method for the jobs property.
     * 
     * <p>
     * For example, to add a new item, do as follows:
     * <pre>
     *    getJobs().add(newItem);
     * </pre>
     * 
     * 
     * <p>
     * Objects of the following type(s) are allowed in the list
     * {@link Job }
     * 
     * 
     */
    public List<Job> getJobs() {
        if (jobs == null) {
            jobs = new ArrayList<Job>();
        }
        return this.jobs;
    }

    public void setJAXBElementName(QName name) {
        this.jaxbElementName = name;
    }

    public QName getJAXBElementName() {
        return this.jaxbElementName;
    }

    public void afterUnmarshal(Unmarshaller u, Object parent) {
        if (parent instanceof JAXBElement) {
            this.jaxbElementName = ((JAXBElement) parent).getName();
        }
    }

    public void accept(Visitor aVisitor) {
        aVisitor.visit(this);
    }

    public Object clone() {
        return copyTo(createNewInstance());
    }

    public Object copyTo(Object target) {
        final CopyStrategy strategy = JAXBCopyStrategy.INSTANCE;
        return copyTo(null, target, strategy);
    }

    public Object copyTo(ObjectLocator locator, Object target, CopyStrategy strategy) {
        final Object draftCopy = ((target == null)?createNewInstance():target);
        if (draftCopy instanceof Queue) {
            final Queue copy = ((Queue) draftCopy);
            if (this.priority!= null) {
                QueuePriority sourcePriority;
                sourcePriority = this.getPriority();
                QueuePriority copyPriority = ((QueuePriority) strategy.copy(LocatorUtils.property(locator, "priority", sourcePriority), sourcePriority));
                copy.setPriority(copyPriority);
            } else {
                copy.priority = null;
            }
            if ((this.possibleProperties!= null)&&(!this.possibleProperties.isEmpty())) {
                List<QueuePossibleProp> sourcePossibleProperties;
                sourcePossibleProperties = (((this.possibleProperties!= null)&&(!this.possibleProperties.isEmpty()))?this.getPossibleProperties():null);
                @SuppressWarnings("unchecked")
                List<QueuePossibleProp> copyPossibleProperties = ((List<QueuePossibleProp> ) strategy.copy(LocatorUtils.property(locator, "possibleProperties", sourcePossibleProperties), sourcePossibleProperties));
                copy.possibleProperties = null;
                if (copyPossibleProperties!= null) {
                    List<QueuePossibleProp> uniquePossiblePropertiesl = copy.getPossibleProperties();
                    uniquePossiblePropertiesl.addAll(copyPossibleProperties);
                }
            } else {
                copy.possibleProperties = null;
            }
            if ((this.forcedProperties!= null)&&(!this.forcedProperties.isEmpty())) {
                List<QueueForcedProp> sourceForcedProperties;
                sourceForcedProperties = (((this.forcedProperties!= null)&&(!this.forcedProperties.isEmpty()))?this.getForcedProperties():null);
                @SuppressWarnings("unchecked")
                List<QueueForcedProp> copyForcedProperties = ((List<QueueForcedProp> ) strategy.copy(LocatorUtils.property(locator, "forcedProperties", sourceForcedProperties), sourceForcedProperties));
                copy.forcedProperties = null;
                if (copyForcedProperties!= null) {
                    List<QueueForcedProp> uniqueForcedPropertiesl = copy.getForcedProperties();
                    uniqueForcedPropertiesl.addAll(copyForcedProperties);
                }
            } else {
                copy.forcedProperties = null;
            }
            if (this.wallTimeLimit!= null) {
                JobLimit sourceWallTimeLimit;
                sourceWallTimeLimit = this.getWallTimeLimit();
                JobLimit copyWallTimeLimit = ((JobLimit) strategy.copy(LocatorUtils.property(locator, "wallTimeLimit", sourceWallTimeLimit), sourceWallTimeLimit));
                copy.setWallTimeLimit(copyWallTimeLimit);
            } else {
                copy.wallTimeLimit = null;
            }
            if (this.numberOfNodesLimit!= null) {
                JobLimit sourceNumberOfNodesLimit;
                sourceNumberOfNodesLimit = this.getNumberOfNodesLimit();
                JobLimit copyNumberOfNodesLimit = ((JobLimit) strategy.copy(LocatorUtils.property(locator, "numberOfNodesLimit", sourceNumberOfNodesLimit), sourceNumberOfNodesLimit));
                copy.setNumberOfNodesLimit(copyNumberOfNodesLimit);
            } else {
                copy.numberOfNodesLimit = null;
            }
            if ((this.jobs!= null)&&(!this.jobs.isEmpty())) {
                List<Job> sourceJobs;
                sourceJobs = (((this.jobs!= null)&&(!this.jobs.isEmpty()))?this.getJobs():null);
                @SuppressWarnings("unchecked")
                List<Job> copyJobs = ((List<Job> ) strategy.copy(LocatorUtils.property(locator, "jobs", sourceJobs), sourceJobs));
                copy.jobs = null;
                if (copyJobs!= null) {
                    List<Job> uniqueJobsl = copy.getJobs();
                    uniqueJobsl.addAll(copyJobs);
                }
            } else {
                copy.jobs = null;
            }
        }
        return draftCopy;
    }

    public Object createNewInstance() {
        return new Queue();
    }

}
