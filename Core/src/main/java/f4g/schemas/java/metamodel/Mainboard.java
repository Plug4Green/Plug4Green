//
// This file was generated by the JavaTM Architecture for XML Binding(JAXB) Reference Implementation, v2.2.11 
// See <a href="http://java.sun.com/xml/jaxb">http://java.sun.com/xml/jaxb</a> 
// Any modifications to this file will be lost upon recompilation of the source schema. 
// Generated on: 2015.08.10 at 04:34:50 PM CEST 
//


package f4g.schemas.java.metamodel;

import java.util.ArrayList;
import java.util.List;
import javax.xml.bind.JAXBElement;
import javax.xml.bind.Unmarshaller;
import javax.xml.bind.annotation.XmlAccessType;
import javax.xml.bind.annotation.XmlAccessorType;
import javax.xml.bind.annotation.XmlElement;
import javax.xml.bind.annotation.XmlSchemaType;
import javax.xml.bind.annotation.XmlTransient;
import javax.xml.bind.annotation.XmlType;
import javax.xml.namespace.QName;
import com.massfords.humantask.Named;
import com.massfords.humantask.Visitable;
import com.massfords.humantask.Visitor;
import org.jvnet.jaxb2_commons.lang.CopyStrategy;
import org.jvnet.jaxb2_commons.lang.CopyTo;
import org.jvnet.jaxb2_commons.lang.JAXBCopyStrategy;
import org.jvnet.jaxb2_commons.locator.ObjectLocator;
import org.jvnet.jaxb2_commons.locator.util.LocatorUtils;


/**
 * <p>Java class for Mainboard complex type.
 * 
 * <p>The following schema fragment specifies the expected content contained within this class.
 * 
 * <pre>
 * &lt;complexType name="Mainboard"&gt;
 *   &lt;complexContent&gt;
 *     &lt;restriction base="{http://www.w3.org/2001/XMLSchema}anyType"&gt;
 *       &lt;sequence&gt;
 *         &lt;element name="frameworkID" type="{http://www.w3.org/2001/XMLSchema}string" minOccurs="0"/&gt;
 *         &lt;element name="powerIdle" type="{f4g/schemas/java/MetaModel}Power"/&gt;
 *         &lt;element name="powerMax" type="{f4g/schemas/java/MetaModel}Power"/&gt;
 *         &lt;element name="computedPower" type="{f4g/schemas/java/MetaModel}Power" minOccurs="0"/&gt;
 *         &lt;element name="memoryUsage" type="{f4g/schemas/java/MetaModel}MemoryUsage" minOccurs="0"/&gt;
 *         &lt;element ref="{f4g/schemas/java/MetaModel}EthernetNIC" maxOccurs="unbounded" minOccurs="0"/&gt;
 *         &lt;element ref="{f4g/schemas/java/MetaModel}FiberchannelNIC" maxOccurs="unbounded" minOccurs="0"/&gt;
 *         &lt;element ref="{f4g/schemas/java/MetaModel}HardwareRAID" maxOccurs="unbounded" minOccurs="0"/&gt;
 *         &lt;element ref="{f4g/schemas/java/MetaModel}SolidStateDisk" maxOccurs="unbounded" minOccurs="0"/&gt;
 *         &lt;element ref="{f4g/schemas/java/MetaModel}HardDisk" maxOccurs="unbounded" minOccurs="0"/&gt;
 *         &lt;element ref="{f4g/schemas/java/MetaModel}LUN" maxOccurs="unbounded" minOccurs="0"/&gt;
 *         &lt;element ref="{f4g/schemas/java/MetaModel}CPU" maxOccurs="unbounded" minOccurs="0"/&gt;
 *         &lt;element ref="{f4g/schemas/java/MetaModel}RAMStick" maxOccurs="unbounded" minOccurs="0"/&gt;
 *         &lt;element ref="{f4g/schemas/java/MetaModel}GPU" maxOccurs="unbounded" minOccurs="0"/&gt;
 *       &lt;/sequence&gt;
 *     &lt;/restriction&gt;
 *   &lt;/complexContent&gt;
 * &lt;/complexType&gt;
 * </pre>
 * 
 * 
 */
@XmlAccessorType(XmlAccessType.FIELD)
@XmlType(name = "Mainboard", propOrder = {
    "frameworkID",
    "powerIdle",
    "powerMax",
    "computedPower",
    "memoryUsage",
    "ethernetNIC",
    "fiberchannelNIC",
    "hardwareRAID",
    "solidStateDisk",
    "hardDisk",
    "lun",
    "cpu",
    "ramStick",
    "gpu"
})
public class Mainboard implements Cloneable, Named, Visitable, CopyTo
{

    protected String frameworkID;
    @XmlElement(required = true)
    @XmlSchemaType(name = "double")
    protected Power powerIdle;
    @XmlElement(required = true)
    @XmlSchemaType(name = "double")
    protected Power powerMax;
    @XmlSchemaType(name = "double")
    protected Power computedPower;
    @XmlSchemaType(name = "double")
    protected MemoryUsage memoryUsage;
    @XmlElement(name = "EthernetNIC", namespace = "f4g/schemas/java/MetaModel")
    protected List<NIC> ethernetNIC;
    @XmlElement(name = "FiberchannelNIC", namespace = "f4g/schemas/java/MetaModel")
    protected List<NIC> fiberchannelNIC;
    @XmlElement(name = "HardwareRAID", namespace = "f4g/schemas/java/MetaModel")
    protected List<HardwareRAID> hardwareRAID;
    @XmlElement(name = "SolidStateDisk", namespace = "f4g/schemas/java/MetaModel")
    protected List<SolidStateDisk> solidStateDisk;
    @XmlElement(name = "HardDisk", namespace = "f4g/schemas/java/MetaModel")
    protected List<HardDisk> hardDisk;
    @XmlElement(name = "LUN", namespace = "f4g/schemas/java/MetaModel")
    protected List<LUN> lun;
    @XmlElement(name = "CPU", namespace = "f4g/schemas/java/MetaModel")
    protected List<CPU> cpu;
    @XmlElement(name = "RAMStick", namespace = "f4g/schemas/java/MetaModel")
    protected List<RAMStick> ramStick;
    @XmlElement(name = "GPU", namespace = "f4g/schemas/java/MetaModel")
    protected List<GPU> gpu;
    @XmlTransient
    private QName jaxbElementName;

    /**
     * Default no-arg constructor
     * 
     */
    public Mainboard() {
        super();
    }

    /**
     * Fully-initialising value constructor
     * 
     */
    public Mainboard(final String frameworkID, final Power powerIdle, final Power powerMax, final Power computedPower, final MemoryUsage memoryUsage, final List<NIC> ethernetNIC, final List<NIC> fiberchannelNIC, final List<HardwareRAID> hardwareRAID, final List<SolidStateDisk> solidStateDisk, final List<HardDisk> hardDisk, final List<LUN> lun, final List<CPU> cpu, final List<RAMStick> ramStick, final List<GPU> gpu, final QName jaxbElementName) {
        this.frameworkID = frameworkID;
        this.powerIdle = powerIdle;
        this.powerMax = powerMax;
        this.computedPower = computedPower;
        this.memoryUsage = memoryUsage;
        this.ethernetNIC = ethernetNIC;
        this.fiberchannelNIC = fiberchannelNIC;
        this.hardwareRAID = hardwareRAID;
        this.solidStateDisk = solidStateDisk;
        this.hardDisk = hardDisk;
        this.lun = lun;
        this.cpu = cpu;
        this.ramStick = ramStick;
        this.gpu = gpu;
        this.jaxbElementName = jaxbElementName;
    }

    /**
     * Gets the value of the frameworkID property.
     * 
     * @return
     *     possible object is
     *     {@link String }
     *     
     */
    public String getFrameworkID() {
        return frameworkID;
    }

    /**
     * Sets the value of the frameworkID property.
     * 
     * @param value
     *     allowed object is
     *     {@link String }
     *     
     */
    public void setFrameworkID(String value) {
        this.frameworkID = value;
    }

    /**
     * Gets the value of the powerIdle property.
     * 
     * @return
     *     possible object is
     *     {@link Power }
     *     
     */
    public Power getPowerIdle() {
        return powerIdle;
    }

    /**
     * Sets the value of the powerIdle property.
     * 
     * @param value
     *     allowed object is
     *     {@link Power }
     *     
     */
    public void setPowerIdle(Power value) {
        this.powerIdle = value;
    }

    /**
     * Gets the value of the powerMax property.
     * 
     * @return
     *     possible object is
     *     {@link Power }
     *     
     */
    public Power getPowerMax() {
        return powerMax;
    }

    /**
     * Sets the value of the powerMax property.
     * 
     * @param value
     *     allowed object is
     *     {@link Power }
     *     
     */
    public void setPowerMax(Power value) {
        this.powerMax = value;
    }

    /**
     * Gets the value of the computedPower property.
     * 
     * @return
     *     possible object is
     *     {@link Power }
     *     
     */
    public Power getComputedPower() {
        return computedPower;
    }

    /**
     * Sets the value of the computedPower property.
     * 
     * @param value
     *     allowed object is
     *     {@link Power }
     *     
     */
    public void setComputedPower(Power value) {
        this.computedPower = value;
    }

    /**
     * Gets the value of the memoryUsage property.
     * 
     * @return
     *     possible object is
     *     {@link MemoryUsage }
     *     
     */
    public MemoryUsage getMemoryUsage() {
        return memoryUsage;
    }

    /**
     * Sets the value of the memoryUsage property.
     * 
     * @param value
     *     allowed object is
     *     {@link MemoryUsage }
     *     
     */
    public void setMemoryUsage(MemoryUsage value) {
        this.memoryUsage = value;
    }

    /**
     * Gets the value of the ethernetNIC property.
     * 
     * <p>
     * This accessor method returns a reference to the live list,
     * not a snapshot. Therefore any modification you make to the
     * returned list will be present inside the JAXB object.
     * This is why there is not a <CODE>set</CODE> method for the ethernetNIC property.
     * 
     * <p>
     * For example, to add a new item, do as follows:
     * <pre>
     *    getEthernetNIC().add(newItem);
     * </pre>
     * 
     * 
     * <p>
     * Objects of the following type(s) are allowed in the list
     * {@link NIC }
     * 
     * 
     */
    public List<NIC> getEthernetNIC() {
        if (ethernetNIC == null) {
            ethernetNIC = new ArrayList<NIC>();
        }
        return this.ethernetNIC;
    }

    /**
     * Gets the value of the fiberchannelNIC property.
     * 
     * <p>
     * This accessor method returns a reference to the live list,
     * not a snapshot. Therefore any modification you make to the
     * returned list will be present inside the JAXB object.
     * This is why there is not a <CODE>set</CODE> method for the fiberchannelNIC property.
     * 
     * <p>
     * For example, to add a new item, do as follows:
     * <pre>
     *    getFiberchannelNIC().add(newItem);
     * </pre>
     * 
     * 
     * <p>
     * Objects of the following type(s) are allowed in the list
     * {@link NIC }
     * 
     * 
     */
    public List<NIC> getFiberchannelNIC() {
        if (fiberchannelNIC == null) {
            fiberchannelNIC = new ArrayList<NIC>();
        }
        return this.fiberchannelNIC;
    }

    /**
     * Gets the value of the hardwareRAID property.
     * 
     * <p>
     * This accessor method returns a reference to the live list,
     * not a snapshot. Therefore any modification you make to the
     * returned list will be present inside the JAXB object.
     * This is why there is not a <CODE>set</CODE> method for the hardwareRAID property.
     * 
     * <p>
     * For example, to add a new item, do as follows:
     * <pre>
     *    getHardwareRAID().add(newItem);
     * </pre>
     * 
     * 
     * <p>
     * Objects of the following type(s) are allowed in the list
     * {@link HardwareRAID }
     * 
     * 
     */
    public List<HardwareRAID> getHardwareRAID() {
        if (hardwareRAID == null) {
            hardwareRAID = new ArrayList<HardwareRAID>();
        }
        return this.hardwareRAID;
    }

    /**
     * Gets the value of the solidStateDisk property.
     * 
     * <p>
     * This accessor method returns a reference to the live list,
     * not a snapshot. Therefore any modification you make to the
     * returned list will be present inside the JAXB object.
     * This is why there is not a <CODE>set</CODE> method for the solidStateDisk property.
     * 
     * <p>
     * For example, to add a new item, do as follows:
     * <pre>
     *    getSolidStateDisk().add(newItem);
     * </pre>
     * 
     * 
     * <p>
     * Objects of the following type(s) are allowed in the list
     * {@link SolidStateDisk }
     * 
     * 
     */
    public List<SolidStateDisk> getSolidStateDisk() {
        if (solidStateDisk == null) {
            solidStateDisk = new ArrayList<SolidStateDisk>();
        }
        return this.solidStateDisk;
    }

    /**
     * Gets the value of the hardDisk property.
     * 
     * <p>
     * This accessor method returns a reference to the live list,
     * not a snapshot. Therefore any modification you make to the
     * returned list will be present inside the JAXB object.
     * This is why there is not a <CODE>set</CODE> method for the hardDisk property.
     * 
     * <p>
     * For example, to add a new item, do as follows:
     * <pre>
     *    getHardDisk().add(newItem);
     * </pre>
     * 
     * 
     * <p>
     * Objects of the following type(s) are allowed in the list
     * {@link HardDisk }
     * 
     * 
     */
    public List<HardDisk> getHardDisk() {
        if (hardDisk == null) {
            hardDisk = new ArrayList<HardDisk>();
        }
        return this.hardDisk;
    }

    /**
     * Gets the value of the lun property.
     * 
     * <p>
     * This accessor method returns a reference to the live list,
     * not a snapshot. Therefore any modification you make to the
     * returned list will be present inside the JAXB object.
     * This is why there is not a <CODE>set</CODE> method for the lun property.
     * 
     * <p>
     * For example, to add a new item, do as follows:
     * <pre>
     *    getLUN().add(newItem);
     * </pre>
     * 
     * 
     * <p>
     * Objects of the following type(s) are allowed in the list
     * {@link LUN }
     * 
     * 
     */
    public List<LUN> getLUN() {
        if (lun == null) {
            lun = new ArrayList<LUN>();
        }
        return this.lun;
    }

    /**
     * Gets the value of the cpu property.
     * 
     * <p>
     * This accessor method returns a reference to the live list,
     * not a snapshot. Therefore any modification you make to the
     * returned list will be present inside the JAXB object.
     * This is why there is not a <CODE>set</CODE> method for the cpu property.
     * 
     * <p>
     * For example, to add a new item, do as follows:
     * <pre>
     *    getCPU().add(newItem);
     * </pre>
     * 
     * 
     * <p>
     * Objects of the following type(s) are allowed in the list
     * {@link CPU }
     * 
     * 
     */
    public List<CPU> getCPU() {
        if (cpu == null) {
            cpu = new ArrayList<CPU>();
        }
        return this.cpu;
    }

    /**
     * Gets the value of the ramStick property.
     * 
     * <p>
     * This accessor method returns a reference to the live list,
     * not a snapshot. Therefore any modification you make to the
     * returned list will be present inside the JAXB object.
     * This is why there is not a <CODE>set</CODE> method for the ramStick property.
     * 
     * <p>
     * For example, to add a new item, do as follows:
     * <pre>
     *    getRAMStick().add(newItem);
     * </pre>
     * 
     * 
     * <p>
     * Objects of the following type(s) are allowed in the list
     * {@link RAMStick }
     * 
     * 
     */
    public List<RAMStick> getRAMStick() {
        if (ramStick == null) {
            ramStick = new ArrayList<RAMStick>();
        }
        return this.ramStick;
    }

    /**
     * Gets the value of the gpu property.
     * 
     * <p>
     * This accessor method returns a reference to the live list,
     * not a snapshot. Therefore any modification you make to the
     * returned list will be present inside the JAXB object.
     * This is why there is not a <CODE>set</CODE> method for the gpu property.
     * 
     * <p>
     * For example, to add a new item, do as follows:
     * <pre>
     *    getGPU().add(newItem);
     * </pre>
     * 
     * 
     * <p>
     * Objects of the following type(s) are allowed in the list
     * {@link GPU }
     * 
     * 
     */
    public List<GPU> getGPU() {
        if (gpu == null) {
            gpu = new ArrayList<GPU>();
        }
        return this.gpu;
    }

    public void setJAXBElementName(QName name) {
        this.jaxbElementName = name;
    }

    public QName getJAXBElementName() {
        return this.jaxbElementName;
    }

    public void afterUnmarshal(Unmarshaller u, Object parent) {
        if (parent instanceof JAXBElement) {
            this.jaxbElementName = ((JAXBElement) parent).getName();
        }
    }

    public void accept(Visitor aVisitor) {
        aVisitor.visit(this);
    }

    public Object clone() {
        return copyTo(createNewInstance());
    }

    public Object copyTo(Object target) {
        final CopyStrategy strategy = JAXBCopyStrategy.INSTANCE;
        return copyTo(null, target, strategy);
    }

    public Object copyTo(ObjectLocator locator, Object target, CopyStrategy strategy) {
        final Object draftCopy = ((target == null)?createNewInstance():target);
        if (draftCopy instanceof Mainboard) {
            final Mainboard copy = ((Mainboard) draftCopy);
            if (this.frameworkID!= null) {
                String sourceFrameworkID;
                sourceFrameworkID = this.getFrameworkID();
                String copyFrameworkID = ((String) strategy.copy(LocatorUtils.property(locator, "frameworkID", sourceFrameworkID), sourceFrameworkID));
                copy.setFrameworkID(copyFrameworkID);
            } else {
                copy.frameworkID = null;
            }
            if (this.powerIdle!= null) {
                Power sourcePowerIdle;
                sourcePowerIdle = this.getPowerIdle();
                Power copyPowerIdle = ((Power) strategy.copy(LocatorUtils.property(locator, "powerIdle", sourcePowerIdle), sourcePowerIdle));
                copy.setPowerIdle(copyPowerIdle);
            } else {
                copy.powerIdle = null;
            }
            if (this.powerMax!= null) {
                Power sourcePowerMax;
                sourcePowerMax = this.getPowerMax();
                Power copyPowerMax = ((Power) strategy.copy(LocatorUtils.property(locator, "powerMax", sourcePowerMax), sourcePowerMax));
                copy.setPowerMax(copyPowerMax);
            } else {
                copy.powerMax = null;
            }
            if (this.computedPower!= null) {
                Power sourceComputedPower;
                sourceComputedPower = this.getComputedPower();
                Power copyComputedPower = ((Power) strategy.copy(LocatorUtils.property(locator, "computedPower", sourceComputedPower), sourceComputedPower));
                copy.setComputedPower(copyComputedPower);
            } else {
                copy.computedPower = null;
            }
            if (this.memoryUsage!= null) {
                MemoryUsage sourceMemoryUsage;
                sourceMemoryUsage = this.getMemoryUsage();
                MemoryUsage copyMemoryUsage = ((MemoryUsage) strategy.copy(LocatorUtils.property(locator, "memoryUsage", sourceMemoryUsage), sourceMemoryUsage));
                copy.setMemoryUsage(copyMemoryUsage);
            } else {
                copy.memoryUsage = null;
            }
            if ((this.ethernetNIC!= null)&&(!this.ethernetNIC.isEmpty())) {
                List<NIC> sourceEthernetNIC;
                sourceEthernetNIC = (((this.ethernetNIC!= null)&&(!this.ethernetNIC.isEmpty()))?this.getEthernetNIC():null);
                @SuppressWarnings("unchecked")
                List<NIC> copyEthernetNIC = ((List<NIC> ) strategy.copy(LocatorUtils.property(locator, "ethernetNIC", sourceEthernetNIC), sourceEthernetNIC));
                copy.ethernetNIC = null;
                if (copyEthernetNIC!= null) {
                    List<NIC> uniqueEthernetNICl = copy.getEthernetNIC();
                    uniqueEthernetNICl.addAll(copyEthernetNIC);
                }
            } else {
                copy.ethernetNIC = null;
            }
            if ((this.fiberchannelNIC!= null)&&(!this.fiberchannelNIC.isEmpty())) {
                List<NIC> sourceFiberchannelNIC;
                sourceFiberchannelNIC = (((this.fiberchannelNIC!= null)&&(!this.fiberchannelNIC.isEmpty()))?this.getFiberchannelNIC():null);
                @SuppressWarnings("unchecked")
                List<NIC> copyFiberchannelNIC = ((List<NIC> ) strategy.copy(LocatorUtils.property(locator, "fiberchannelNIC", sourceFiberchannelNIC), sourceFiberchannelNIC));
                copy.fiberchannelNIC = null;
                if (copyFiberchannelNIC!= null) {
                    List<NIC> uniqueFiberchannelNICl = copy.getFiberchannelNIC();
                    uniqueFiberchannelNICl.addAll(copyFiberchannelNIC);
                }
            } else {
                copy.fiberchannelNIC = null;
            }
            if ((this.hardwareRAID!= null)&&(!this.hardwareRAID.isEmpty())) {
                List<HardwareRAID> sourceHardwareRAID;
                sourceHardwareRAID = (((this.hardwareRAID!= null)&&(!this.hardwareRAID.isEmpty()))?this.getHardwareRAID():null);
                @SuppressWarnings("unchecked")
                List<HardwareRAID> copyHardwareRAID = ((List<HardwareRAID> ) strategy.copy(LocatorUtils.property(locator, "hardwareRAID", sourceHardwareRAID), sourceHardwareRAID));
                copy.hardwareRAID = null;
                if (copyHardwareRAID!= null) {
                    List<HardwareRAID> uniqueHardwareRAIDl = copy.getHardwareRAID();
                    uniqueHardwareRAIDl.addAll(copyHardwareRAID);
                }
            } else {
                copy.hardwareRAID = null;
            }
            if ((this.solidStateDisk!= null)&&(!this.solidStateDisk.isEmpty())) {
                List<SolidStateDisk> sourceSolidStateDisk;
                sourceSolidStateDisk = (((this.solidStateDisk!= null)&&(!this.solidStateDisk.isEmpty()))?this.getSolidStateDisk():null);
                @SuppressWarnings("unchecked")
                List<SolidStateDisk> copySolidStateDisk = ((List<SolidStateDisk> ) strategy.copy(LocatorUtils.property(locator, "solidStateDisk", sourceSolidStateDisk), sourceSolidStateDisk));
                copy.solidStateDisk = null;
                if (copySolidStateDisk!= null) {
                    List<SolidStateDisk> uniqueSolidStateDiskl = copy.getSolidStateDisk();
                    uniqueSolidStateDiskl.addAll(copySolidStateDisk);
                }
            } else {
                copy.solidStateDisk = null;
            }
            if ((this.hardDisk!= null)&&(!this.hardDisk.isEmpty())) {
                List<HardDisk> sourceHardDisk;
                sourceHardDisk = (((this.hardDisk!= null)&&(!this.hardDisk.isEmpty()))?this.getHardDisk():null);
                @SuppressWarnings("unchecked")
                List<HardDisk> copyHardDisk = ((List<HardDisk> ) strategy.copy(LocatorUtils.property(locator, "hardDisk", sourceHardDisk), sourceHardDisk));
                copy.hardDisk = null;
                if (copyHardDisk!= null) {
                    List<HardDisk> uniqueHardDiskl = copy.getHardDisk();
                    uniqueHardDiskl.addAll(copyHardDisk);
                }
            } else {
                copy.hardDisk = null;
            }
            if ((this.lun!= null)&&(!this.lun.isEmpty())) {
                List<LUN> sourceLUN;
                sourceLUN = (((this.lun!= null)&&(!this.lun.isEmpty()))?this.getLUN():null);
                @SuppressWarnings("unchecked")
                List<LUN> copyLUN = ((List<LUN> ) strategy.copy(LocatorUtils.property(locator, "lun", sourceLUN), sourceLUN));
                copy.lun = null;
                if (copyLUN!= null) {
                    List<LUN> uniqueLUNl = copy.getLUN();
                    uniqueLUNl.addAll(copyLUN);
                }
            } else {
                copy.lun = null;
            }
            if ((this.cpu!= null)&&(!this.cpu.isEmpty())) {
                List<CPU> sourceCPU;
                sourceCPU = (((this.cpu!= null)&&(!this.cpu.isEmpty()))?this.getCPU():null);
                @SuppressWarnings("unchecked")
                List<CPU> copyCPU = ((List<CPU> ) strategy.copy(LocatorUtils.property(locator, "cpu", sourceCPU), sourceCPU));
                copy.cpu = null;
                if (copyCPU!= null) {
                    List<CPU> uniqueCPUl = copy.getCPU();
                    uniqueCPUl.addAll(copyCPU);
                }
            } else {
                copy.cpu = null;
            }
            if ((this.ramStick!= null)&&(!this.ramStick.isEmpty())) {
                List<RAMStick> sourceRAMStick;
                sourceRAMStick = (((this.ramStick!= null)&&(!this.ramStick.isEmpty()))?this.getRAMStick():null);
                @SuppressWarnings("unchecked")
                List<RAMStick> copyRAMStick = ((List<RAMStick> ) strategy.copy(LocatorUtils.property(locator, "ramStick", sourceRAMStick), sourceRAMStick));
                copy.ramStick = null;
                if (copyRAMStick!= null) {
                    List<RAMStick> uniqueRAMStickl = copy.getRAMStick();
                    uniqueRAMStickl.addAll(copyRAMStick);
                }
            } else {
                copy.ramStick = null;
            }
            if ((this.gpu!= null)&&(!this.gpu.isEmpty())) {
                List<GPU> sourceGPU;
                sourceGPU = (((this.gpu!= null)&&(!this.gpu.isEmpty()))?this.getGPU():null);
                @SuppressWarnings("unchecked")
                List<GPU> copyGPU = ((List<GPU> ) strategy.copy(LocatorUtils.property(locator, "gpu", sourceGPU), sourceGPU));
                copy.gpu = null;
                if (copyGPU!= null) {
                    List<GPU> uniqueGPUl = copy.getGPU();
                    uniqueGPUl.addAll(copyGPU);
                }
            } else {
                copy.gpu = null;
            }
        }
        return draftCopy;
    }

    public Object createNewInstance() {
        return new Mainboard();
    }

}
