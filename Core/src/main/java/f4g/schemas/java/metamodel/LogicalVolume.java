//
// This file was generated by the JavaTM Architecture for XML Binding(JAXB) Reference Implementation, v2.2.11 
// See <a href="http://java.sun.com/xml/jaxb">http://java.sun.com/xml/jaxb</a> 
// Any modifications to this file will be lost upon recompilation of the source schema. 
// Generated on: 2015.08.10 at 04:34:50 PM CEST 
//


package f4g.schemas.java.metamodel;

import java.util.ArrayList;
import java.util.List;
import javax.xml.bind.JAXBElement;
import javax.xml.bind.Unmarshaller;
import javax.xml.bind.annotation.XmlAccessType;
import javax.xml.bind.annotation.XmlAccessorType;
import javax.xml.bind.annotation.XmlElement;
import javax.xml.bind.annotation.XmlID;
import javax.xml.bind.annotation.XmlSchemaType;
import javax.xml.bind.annotation.XmlTransient;
import javax.xml.bind.annotation.XmlType;
import javax.xml.bind.annotation.adapters.CollapsedStringAdapter;
import javax.xml.bind.annotation.adapters.XmlJavaTypeAdapter;
import javax.xml.namespace.QName;
import com.massfords.humantask.Named;
import com.massfords.humantask.Visitable;
import com.massfords.humantask.Visitor;
import org.jvnet.jaxb2_commons.lang.CopyStrategy;
import org.jvnet.jaxb2_commons.lang.CopyTo;
import org.jvnet.jaxb2_commons.lang.JAXBCopyStrategy;
import org.jvnet.jaxb2_commons.locator.ObjectLocator;
import org.jvnet.jaxb2_commons.locator.util.LocatorUtils;


/**
 * <p>Java class for LogicalVolume complex type.
 * 
 * <p>The following schema fragment specifies the expected content contained within this class.
 * 
 * <pre>
 * &lt;complexType name="LogicalVolume"&gt;
 *   &lt;complexContent&gt;
 *     &lt;restriction base="{http://www.w3.org/2001/XMLSchema}anyType"&gt;
 *       &lt;sequence&gt;
 *         &lt;element name="logVolId" type="{http://www.w3.org/2001/XMLSchema}ID"/&gt;
 *         &lt;element name="level" type="{f4g/schemas/java/MetaModel}RAIDLevel"/&gt;
 *         &lt;element name="computedPower" type="{f4g/schemas/java/MetaModel}Power" minOccurs="0"/&gt;
 *         &lt;element name="readRate" type="{f4g/schemas/java/MetaModel}IoRate"/&gt;
 *         &lt;element name="writeRate" type="{f4g/schemas/java/MetaModel}IoRate"/&gt;
 *         &lt;element name="maxReadRate" type="{f4g/schemas/java/MetaModel}IoRate"/&gt;
 *         &lt;element name="maxWriteRate" type="{f4g/schemas/java/MetaModel}IoRate"/&gt;
 *         &lt;element name="numberOfReadOps" type="{f4g/schemas/java/MetaModel}OP"/&gt;
 *         &lt;element name="numberOfWriteOps" type="{f4g/schemas/java/MetaModel}OP"/&gt;
 *         &lt;element name="blockSize" type="{f4g/schemas/java/MetaModel}BlockSize"/&gt;
 *         &lt;element ref="{f4g/schemas/java/MetaModel}FileSystem" minOccurs="0"/&gt;
 *         &lt;element ref="{f4g/schemas/java/MetaModel}LogicalUnit" maxOccurs="unbounded" minOccurs="0"/&gt;
 *       &lt;/sequence&gt;
 *     &lt;/restriction&gt;
 *   &lt;/complexContent&gt;
 * &lt;/complexType&gt;
 * </pre>
 * 
 * 
 */
@XmlAccessorType(XmlAccessType.FIELD)
@XmlType(name = "LogicalVolume", propOrder = {
    "logVolId",
    "level",
    "computedPower",
    "readRate",
    "writeRate",
    "maxReadRate",
    "maxWriteRate",
    "numberOfReadOps",
    "numberOfWriteOps",
    "blockSize",
    "fileSystem",
    "logicalUnit"
})
public class LogicalVolume implements Cloneable, Named, Visitable, CopyTo
{

    @XmlElement(required = true)
    @XmlJavaTypeAdapter(CollapsedStringAdapter.class)
    @XmlID
    @XmlSchemaType(name = "ID")
    protected String logVolId;
    @XmlElement(required = true)
    @XmlSchemaType(name = "int")
    protected RAIDLevel level;
    @XmlSchemaType(name = "double")
    protected Power computedPower;
    @XmlElement(required = true)
    @XmlSchemaType(name = "double")
    protected IoRate readRate;
    @XmlElement(required = true)
    @XmlSchemaType(name = "double")
    protected IoRate writeRate;
    @XmlElement(required = true)
    @XmlSchemaType(name = "double")
    protected IoRate maxReadRate;
    @XmlElement(required = true)
    @XmlSchemaType(name = "double")
    protected IoRate maxWriteRate;
    @XmlElement(required = true)
    @XmlSchemaType(name = "int")
    protected OP numberOfReadOps;
    @XmlElement(required = true)
    @XmlSchemaType(name = "int")
    protected OP numberOfWriteOps;
    @XmlElement(required = true)
    @XmlSchemaType(name = "int")
    protected BlockSize blockSize;
    @XmlElement(name = "FileSystem", namespace = "f4g/schemas/java/MetaModel")
    protected FileSystem fileSystem;
    @XmlElement(name = "LogicalUnit", namespace = "f4g/schemas/java/MetaModel")
    protected List<LogicalUnit> logicalUnit;
    @XmlTransient
    private QName jaxbElementName;

    /**
     * Default no-arg constructor
     * 
     */
    public LogicalVolume() {
        super();
    }

    /**
     * Fully-initialising value constructor
     * 
     */
    public LogicalVolume(final String logVolId, final RAIDLevel level, final Power computedPower, final IoRate readRate, final IoRate writeRate, final IoRate maxReadRate, final IoRate maxWriteRate, final OP numberOfReadOps, final OP numberOfWriteOps, final BlockSize blockSize, final FileSystem fileSystem, final List<LogicalUnit> logicalUnit, final QName jaxbElementName) {
        this.logVolId = logVolId;
        this.level = level;
        this.computedPower = computedPower;
        this.readRate = readRate;
        this.writeRate = writeRate;
        this.maxReadRate = maxReadRate;
        this.maxWriteRate = maxWriteRate;
        this.numberOfReadOps = numberOfReadOps;
        this.numberOfWriteOps = numberOfWriteOps;
        this.blockSize = blockSize;
        this.fileSystem = fileSystem;
        this.logicalUnit = logicalUnit;
        this.jaxbElementName = jaxbElementName;
    }

    /**
     * Gets the value of the logVolId property.
     * 
     * @return
     *     possible object is
     *     {@link String }
     *     
     */
    public String getLogVolId() {
        return logVolId;
    }

    /**
     * Sets the value of the logVolId property.
     * 
     * @param value
     *     allowed object is
     *     {@link String }
     *     
     */
    public void setLogVolId(String value) {
        this.logVolId = value;
    }

    /**
     * Gets the value of the level property.
     * 
     * @return
     *     possible object is
     *     {@link RAIDLevel }
     *     
     */
    public RAIDLevel getLevel() {
        return level;
    }

    /**
     * Sets the value of the level property.
     * 
     * @param value
     *     allowed object is
     *     {@link RAIDLevel }
     *     
     */
    public void setLevel(RAIDLevel value) {
        this.level = value;
    }

    /**
     * Gets the value of the computedPower property.
     * 
     * @return
     *     possible object is
     *     {@link Power }
     *     
     */
    public Power getComputedPower() {
        return computedPower;
    }

    /**
     * Sets the value of the computedPower property.
     * 
     * @param value
     *     allowed object is
     *     {@link Power }
     *     
     */
    public void setComputedPower(Power value) {
        this.computedPower = value;
    }

    /**
     * Gets the value of the readRate property.
     * 
     * @return
     *     possible object is
     *     {@link IoRate }
     *     
     */
    public IoRate getReadRate() {
        return readRate;
    }

    /**
     * Sets the value of the readRate property.
     * 
     * @param value
     *     allowed object is
     *     {@link IoRate }
     *     
     */
    public void setReadRate(IoRate value) {
        this.readRate = value;
    }

    /**
     * Gets the value of the writeRate property.
     * 
     * @return
     *     possible object is
     *     {@link IoRate }
     *     
     */
    public IoRate getWriteRate() {
        return writeRate;
    }

    /**
     * Sets the value of the writeRate property.
     * 
     * @param value
     *     allowed object is
     *     {@link IoRate }
     *     
     */
    public void setWriteRate(IoRate value) {
        this.writeRate = value;
    }

    /**
     * Gets the value of the maxReadRate property.
     * 
     * @return
     *     possible object is
     *     {@link IoRate }
     *     
     */
    public IoRate getMaxReadRate() {
        return maxReadRate;
    }

    /**
     * Sets the value of the maxReadRate property.
     * 
     * @param value
     *     allowed object is
     *     {@link IoRate }
     *     
     */
    public void setMaxReadRate(IoRate value) {
        this.maxReadRate = value;
    }

    /**
     * Gets the value of the maxWriteRate property.
     * 
     * @return
     *     possible object is
     *     {@link IoRate }
     *     
     */
    public IoRate getMaxWriteRate() {
        return maxWriteRate;
    }

    /**
     * Sets the value of the maxWriteRate property.
     * 
     * @param value
     *     allowed object is
     *     {@link IoRate }
     *     
     */
    public void setMaxWriteRate(IoRate value) {
        this.maxWriteRate = value;
    }

    /**
     * Gets the value of the numberOfReadOps property.
     * 
     * @return
     *     possible object is
     *     {@link OP }
     *     
     */
    public OP getNumberOfReadOps() {
        return numberOfReadOps;
    }

    /**
     * Sets the value of the numberOfReadOps property.
     * 
     * @param value
     *     allowed object is
     *     {@link OP }
     *     
     */
    public void setNumberOfReadOps(OP value) {
        this.numberOfReadOps = value;
    }

    /**
     * Gets the value of the numberOfWriteOps property.
     * 
     * @return
     *     possible object is
     *     {@link OP }
     *     
     */
    public OP getNumberOfWriteOps() {
        return numberOfWriteOps;
    }

    /**
     * Sets the value of the numberOfWriteOps property.
     * 
     * @param value
     *     allowed object is
     *     {@link OP }
     *     
     */
    public void setNumberOfWriteOps(OP value) {
        this.numberOfWriteOps = value;
    }

    /**
     * Gets the value of the blockSize property.
     * 
     * @return
     *     possible object is
     *     {@link BlockSize }
     *     
     */
    public BlockSize getBlockSize() {
        return blockSize;
    }

    /**
     * Sets the value of the blockSize property.
     * 
     * @param value
     *     allowed object is
     *     {@link BlockSize }
     *     
     */
    public void setBlockSize(BlockSize value) {
        this.blockSize = value;
    }

    /**
     * Gets the value of the fileSystem property.
     * 
     * @return
     *     possible object is
     *     {@link FileSystem }
     *     
     */
    public FileSystem getFileSystem() {
        return fileSystem;
    }

    /**
     * Sets the value of the fileSystem property.
     * 
     * @param value
     *     allowed object is
     *     {@link FileSystem }
     *     
     */
    public void setFileSystem(FileSystem value) {
        this.fileSystem = value;
    }

    /**
     * Gets the value of the logicalUnit property.
     * 
     * <p>
     * This accessor method returns a reference to the live list,
     * not a snapshot. Therefore any modification you make to the
     * returned list will be present inside the JAXB object.
     * This is why there is not a <CODE>set</CODE> method for the logicalUnit property.
     * 
     * <p>
     * For example, to add a new item, do as follows:
     * <pre>
     *    getLogicalUnit().add(newItem);
     * </pre>
     * 
     * 
     * <p>
     * Objects of the following type(s) are allowed in the list
     * {@link LogicalUnit }
     * 
     * 
     */
    public List<LogicalUnit> getLogicalUnit() {
        if (logicalUnit == null) {
            logicalUnit = new ArrayList<LogicalUnit>();
        }
        return this.logicalUnit;
    }

    public void setJAXBElementName(QName name) {
        this.jaxbElementName = name;
    }

    public QName getJAXBElementName() {
        return this.jaxbElementName;
    }

    public void afterUnmarshal(Unmarshaller u, Object parent) {
        if (parent instanceof JAXBElement) {
            this.jaxbElementName = ((JAXBElement) parent).getName();
        }
    }

    public void accept(Visitor aVisitor) {
        aVisitor.visit(this);
    }

    public Object clone() {
        return copyTo(createNewInstance());
    }

    public Object copyTo(Object target) {
        final CopyStrategy strategy = JAXBCopyStrategy.INSTANCE;
        return copyTo(null, target, strategy);
    }

    public Object copyTo(ObjectLocator locator, Object target, CopyStrategy strategy) {
        final Object draftCopy = ((target == null)?createNewInstance():target);
        if (draftCopy instanceof LogicalVolume) {
            final LogicalVolume copy = ((LogicalVolume) draftCopy);
            if (this.logVolId!= null) {
                String sourceLogVolId;
                sourceLogVolId = this.getLogVolId();
                String copyLogVolId = ((String) strategy.copy(LocatorUtils.property(locator, "logVolId", sourceLogVolId), sourceLogVolId));
                copy.setLogVolId(copyLogVolId);
            } else {
                copy.logVolId = null;
            }
            if (this.level!= null) {
                RAIDLevel sourceLevel;
                sourceLevel = this.getLevel();
                RAIDLevel copyLevel = ((RAIDLevel) strategy.copy(LocatorUtils.property(locator, "level", sourceLevel), sourceLevel));
                copy.setLevel(copyLevel);
            } else {
                copy.level = null;
            }
            if (this.computedPower!= null) {
                Power sourceComputedPower;
                sourceComputedPower = this.getComputedPower();
                Power copyComputedPower = ((Power) strategy.copy(LocatorUtils.property(locator, "computedPower", sourceComputedPower), sourceComputedPower));
                copy.setComputedPower(copyComputedPower);
            } else {
                copy.computedPower = null;
            }
            if (this.readRate!= null) {
                IoRate sourceReadRate;
                sourceReadRate = this.getReadRate();
                IoRate copyReadRate = ((IoRate) strategy.copy(LocatorUtils.property(locator, "readRate", sourceReadRate), sourceReadRate));
                copy.setReadRate(copyReadRate);
            } else {
                copy.readRate = null;
            }
            if (this.writeRate!= null) {
                IoRate sourceWriteRate;
                sourceWriteRate = this.getWriteRate();
                IoRate copyWriteRate = ((IoRate) strategy.copy(LocatorUtils.property(locator, "writeRate", sourceWriteRate), sourceWriteRate));
                copy.setWriteRate(copyWriteRate);
            } else {
                copy.writeRate = null;
            }
            if (this.maxReadRate!= null) {
                IoRate sourceMaxReadRate;
                sourceMaxReadRate = this.getMaxReadRate();
                IoRate copyMaxReadRate = ((IoRate) strategy.copy(LocatorUtils.property(locator, "maxReadRate", sourceMaxReadRate), sourceMaxReadRate));
                copy.setMaxReadRate(copyMaxReadRate);
            } else {
                copy.maxReadRate = null;
            }
            if (this.maxWriteRate!= null) {
                IoRate sourceMaxWriteRate;
                sourceMaxWriteRate = this.getMaxWriteRate();
                IoRate copyMaxWriteRate = ((IoRate) strategy.copy(LocatorUtils.property(locator, "maxWriteRate", sourceMaxWriteRate), sourceMaxWriteRate));
                copy.setMaxWriteRate(copyMaxWriteRate);
            } else {
                copy.maxWriteRate = null;
            }
            if (this.numberOfReadOps!= null) {
                OP sourceNumberOfReadOps;
                sourceNumberOfReadOps = this.getNumberOfReadOps();
                OP copyNumberOfReadOps = ((OP) strategy.copy(LocatorUtils.property(locator, "numberOfReadOps", sourceNumberOfReadOps), sourceNumberOfReadOps));
                copy.setNumberOfReadOps(copyNumberOfReadOps);
            } else {
                copy.numberOfReadOps = null;
            }
            if (this.numberOfWriteOps!= null) {
                OP sourceNumberOfWriteOps;
                sourceNumberOfWriteOps = this.getNumberOfWriteOps();
                OP copyNumberOfWriteOps = ((OP) strategy.copy(LocatorUtils.property(locator, "numberOfWriteOps", sourceNumberOfWriteOps), sourceNumberOfWriteOps));
                copy.setNumberOfWriteOps(copyNumberOfWriteOps);
            } else {
                copy.numberOfWriteOps = null;
            }
            if (this.blockSize!= null) {
                BlockSize sourceBlockSize;
                sourceBlockSize = this.getBlockSize();
                BlockSize copyBlockSize = ((BlockSize) strategy.copy(LocatorUtils.property(locator, "blockSize", sourceBlockSize), sourceBlockSize));
                copy.setBlockSize(copyBlockSize);
            } else {
                copy.blockSize = null;
            }
            if (this.fileSystem!= null) {
                FileSystem sourceFileSystem;
                sourceFileSystem = this.getFileSystem();
                FileSystem copyFileSystem = ((FileSystem) strategy.copy(LocatorUtils.property(locator, "fileSystem", sourceFileSystem), sourceFileSystem));
                copy.setFileSystem(copyFileSystem);
            } else {
                copy.fileSystem = null;
            }
            if ((this.logicalUnit!= null)&&(!this.logicalUnit.isEmpty())) {
                List<LogicalUnit> sourceLogicalUnit;
                sourceLogicalUnit = (((this.logicalUnit!= null)&&(!this.logicalUnit.isEmpty()))?this.getLogicalUnit():null);
                @SuppressWarnings("unchecked")
                List<LogicalUnit> copyLogicalUnit = ((List<LogicalUnit> ) strategy.copy(LocatorUtils.property(locator, "logicalUnit", sourceLogicalUnit), sourceLogicalUnit));
                copy.logicalUnit = null;
                if (copyLogicalUnit!= null) {
                    List<LogicalUnit> uniqueLogicalUnitl = copy.getLogicalUnit();
                    uniqueLogicalUnitl.addAll(copyLogicalUnit);
                }
            } else {
                copy.logicalUnit = null;
            }
        }
        return draftCopy;
    }

    public Object createNewInstance() {
        return new LogicalVolume();
    }

}
